/**
 * API Service
 * Supabase backend integration for Moments
 * 
 * This module provides server-side operations using Supabase.
 * 
 * SYNC STRATEGY (Future Implementation):
 * 
 * 1. Offline-First Approach (Recommended):
 *    - All moments are saved locally first (AsyncStorage)
 *    - Background sync when online
 *    - Queue failed uploads for retry
 *    - Merge server data with local on fetch
 *    - Conflict resolution: local wins or last-write-wins
 * 
 * 2. Sync Flow:
 *    a) User captures moment â†’ Saved locally immediately
 *    b) Background job attempts upload when online
 *    c) On success: Update local record with server ID/timestamp
 *    d) On failure: Keep in local queue, retry later
 *    e) On app start: Fetch server moments, merge with local
 * 
 * 3. Conflict Handling:
 *    - Use `updatedAt` timestamps for conflict resolution
 *    - Local moments without server ID are "pending upload"
 *    - Server moments not in local are "new downloads"
 *    - Merge strategy: Keep both, deduplicate by ID
 * 
 * 4. Offline Support:
 *    - Use NetInfo to detect connectivity
 *    - Queue uploads when offline
 *    - Show sync status in UI
 *    - Allow full app usage offline
 */

import { Moment } from '../types';
import { supabase } from './supabase';

/**
 * Server representation of a Moment
 * Maps to Supabase moments table schema
 */
export interface MomentRecord {
  id: string; // Server-generated UUID
  user_id?: string; // User ID from Supabase auth
  uri: string; // Video URI
  created_at: string; // ISO 8601 date string (server timestamp)
  description?: string; // Optional description
  // Note: Supabase returns snake_case, we'll map to camelCase for local use
}

/**
 * Transforms server MomentRecord to local Moment format
 */
function mapServerToLocal(record: MomentRecord): Moment {
  return {
    id: record.id,
    uri: record.uri,
    createdAt: record.created_at, // Map snake_case to camelCase
    description: record.description,
  };
}

/**
 * Transforms local Moment to server format for insertion
 */
function mapLocalToServer(moment: Moment): Omit<MomentRecord, 'id' | 'created_at'> {
  return {
    uri: moment.uri,
    description: moment.description,
    // Note: id and created_at will be generated by Supabase
  };
}

/**
 * Fetch moments from Supabase
 * Retrieves the latest 50 moments ordered by created_at desc
 * 
 * @returns Promise resolving to array of moment records
 * @throws Error if fetch fails
 */
export async function fetchMoments(): Promise<MomentRecord[]> {
  try {
    const { data, error } = await supabase
      .from('moments')
      .select('id, user_id, uri, created_at, description')
      .order('created_at', { ascending: false })
      .limit(50);

    if (error) {
      console.error('Supabase fetchMoments error:', error);
      throw new Error(`Failed to fetch moments: ${error.message}`);
    }

    if (!data) {
      console.warn('fetchMoments returned null data');
      return [];
    }

    return data as MomentRecord[];
  } catch (error) {
    // Log the error for debugging
    if (error instanceof Error) {
      console.error('fetchMoments failed:', error.message);
      throw error;
    }
    console.error('fetchMoments failed with unknown error:', error);
    throw new Error('Failed to fetch moments: Unknown error');
  }
}

/**
 * Upload a moment to Supabase
 * Inserts a new row into the moments table
 * 
 * @param moment - Local moment to upload
 * @returns Promise resolving to created server record
 * @throws Error if upload fails
 */
export async function uploadMoment(moment: Moment): Promise<MomentRecord> {
  try {
    // Map local moment to server format
    const serverData = mapLocalToServer(moment);

    // Insert into Supabase
    const { data, error } = await supabase
      .from('moments')
      .insert({
        ...serverData,
        // Optionally include id if you want to use the local ID
        // id: moment.id,
        // Or let Supabase generate it
      })
      .select()
      .single();

    if (error) {
      console.error('Supabase uploadMoment error:', error);
      throw new Error(`Failed to upload moment: ${error.message}`);
    }

    if (!data) {
      console.error('uploadMoment returned null data');
      throw new Error('Failed to upload moment: No data returned');
    }

    return data as MomentRecord;
  } catch (error) {
    // Log the error for debugging
    if (error instanceof Error) {
      console.error('uploadMoment failed:', error.message);
      throw error;
    }
    console.error('uploadMoment failed with unknown error:', error);
    throw new Error('Failed to upload moment: Unknown error');
  }
}

/**
 * Delete a moment from the server
 * 
 * @param momentId - ID of moment to delete
 * @returns Promise resolving when deletion is complete
 */
export async function deleteMomentFromServer(momentId: string): Promise<void> {
  try {
    const { error } = await supabase
      .from('moments')
      .delete()
      .eq('id', momentId);

    if (error) {
      console.error('Supabase deleteMomentFromServer error:', error);
      throw new Error(`Failed to delete moment: ${error.message}`);
    }
  } catch (error) {
    if (error instanceof Error) {
      console.error('deleteMomentFromServer failed:', error.message);
      throw error;
    }
    console.error('deleteMomentFromServer failed with unknown error:', error);
    throw new Error('Failed to delete moment: Unknown error');
  }
}

/**
 * Sync local moments with server
 * 
 * TODO: Implement sync logic
 * 
 * This function would:
 * 1. Fetch all server moments
 * 2. Compare with local moments
 * 3. Upload pending local moments
 * 4. Download new server moments
 * 5. Resolve conflicts
 * 6. Update local storage
 * 
 * @param localMoments - Current local moments
 * @returns Promise resolving to synced moments
 */
export async function syncMoments(localMoments: Moment[]): Promise<Moment[]> {
  // TODO: Implement sync logic
  // 
  // Sync strategy:
  // 1. Get server moments using fetchMoments()
  // 2. Identify:
  //    - Local moments without server ID (pending upload)
  //    - Server moments not in local (new downloads)
  //    - Moments in both (check for conflicts)
  // 3. Upload pending moments using uploadMoment()
  // 4. Merge server moments into local
  // 5. Resolve conflicts (prefer newer updatedAt)
  // 6. Return merged list
  
  throw new Error('syncMoments: Not implemented - sync logic pending');
}

/**
 * Check if device is online
 * 
 * TODO: Implement using NetInfo
 * 
 * @returns Promise resolving to true if online, false otherwise
 */
export async function isOnline(): Promise<boolean> {
  // TODO: Implement network check
  // 
  // Example:
  // import NetInfo from '@react-native-community/netinfo';
  // const state = await NetInfo.fetch();
  // return state.isConnected ?? false;
  
  // For now, assume online
  return true;
}

/**
 * Get upload queue (moments pending upload)
 * 
 * TODO: Implement queue management
 * 
 * This would track moments that failed to upload
 * and need retry when connectivity is restored.
 * 
 * @returns Promise resolving to array of moments pending upload
 */
export async function getUploadQueue(): Promise<Moment[]> {
  // TODO: Implement queue retrieval
  // Could use AsyncStorage with a separate key like '@moment_roulette:upload_queue'
  // Or use expo-sqlite for more robust queue management
  
  return [];
}

/**
 * Add moment to upload queue
 * 
 * TODO: Implement queue management
 * 
 * @param moment - Moment to queue for upload
 */
export async function queueForUpload(moment: Moment): Promise<void> {
  // TODO: Implement queue storage
  // Store moment in queue for later retry
}

// Export helper functions for use in sync logic
export { mapServerToLocal, mapLocalToServer };
